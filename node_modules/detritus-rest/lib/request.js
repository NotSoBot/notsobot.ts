"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const communications_1 = require("./communications");
const constants_1 = require("./constants");
const contenttypes_1 = require("./contenttypes");
const encoder_1 = require("./encoder");
const errors_1 = require("./errors");
const response_1 = require("./response");
class Request {
    constructor(options) {
        this.settings = Object.assign({}, options.settings);
        this.url = options.url || {};
        if (!this.url.protocol) {
            this.url.protocol = 'https:';
        }
        this.options = {
            method: options.method,
            headers: options.headers || {},
            protocol: this.url.protocol,
            hostname: this.url.hostname,
            port: this.url.port,
            path: this.url.pathname + this.url.search,
        };
        if (encoder_1.AcceptedEncodings.length) {
            this.options.headers[constants_1.HTTPHeaders.ACCEPT_ENCODING] = encoder_1.AcceptedEncodings.join(',');
        }
        if (!Object.values(constants_1.HTTPProtocols).includes(this.url.protocol)) {
            throw new Error(`Protocol '${this.url.protocol}' not supported, only ${Object.values(constants_1.HTTPProtocols).join(', ')}`);
        }
        this.body = null;
        if ((options.body && options.multipart) || (options.files && options.files.length)) {
            if (options.body instanceof contenttypes_1.MultipartFormData) {
                this.body = options.body;
            }
            else {
                this.body = new contenttypes_1.MultipartFormData();
            }
            this.options.headers[constants_1.HTTPHeaders.CONTENT_TYPE] = this.body.contentType;
            if (options.files && options.files.length) {
                for (let key in options.files) {
                    const file = options.files[key];
                    this.body.add(file.name || `file${key}`, file.data, file);
                }
            }
            if (options.body && !(options.body instanceof contenttypes_1.MultipartFormData)) {
                if (options.multipart) {
                    for (let key in options.body) {
                        this.body.add(key, options.body[key]);
                    }
                }
                else {
                    const key = this.settings.multipartJsonKey || 'payload_json';
                    this.body.add(key, options.body);
                }
            }
            this.body = this.body.done();
        }
        else if (options.body !== undefined) {
            if (options.jsonify || options.jsonify === undefined) {
                // maybe set charset?
                this.options.headers[constants_1.HTTPHeaders.CONTENT_TYPE] = constants_1.SupportedContentTypes.APPLICATION_JSON;
                this.body = JSON.stringify(options.body);
            }
            else {
                this.body = options.body;
            }
        }
        if (!(constants_1.HTTPHeaders.CONTENT_LENGTH in this.options.headers) && !constants_1.BodylessMethods.includes(this.method)) {
            let length = 0;
            if (this.body) {
                if (Array.isArray(this.body)) {
                    for (let chunk of this.body) {
                        length += Buffer.byteLength(chunk);
                    }
                }
                else {
                    length += Buffer.byteLength(this.body);
                }
            }
            this.options.headers[constants_1.HTTPHeaders.CONTENT_LENGTH] = String(length);
        }
        this.route = options.route || null;
    }
    get method() {
        return this.options.method;
    }
    get formatted() {
        return this.toString();
    }
    _createRequest() {
        return new Promise((resolve, reject) => {
            switch (this.options.protocol) {
                case constants_1.HTTPProtocols.HTTP:
                    {
                        resolve({
                            request: communications_1.Communications.HTTP.request({
                                headers: this.options.headers,
                                hostname: this.options.hostname,
                                method: this.options.method,
                                path: this.options.path,
                                port: this.options.port,
                                protocol: this.options.protocol,
                            }),
                            info: { alpn: constants_1.ALPNProtocols.NONE },
                        });
                    }
                    ;
                    break;
                case constants_1.HTTPProtocols.HTTPS:
                    {
                        this.options.port = String(this.options.port || constants_1.HTTPSPort);
                        const socket = communications_1.Communications.TLS.connect({
                            host: this.options.hostname,
                            port: parseInt(this.options.port),
                            servername: this.options.hostname,
                            ALPNProtocols: communications_1.AvailableALPNProtocols,
                        });
                        socket.once('error', (error) => {
                            socket.destroy();
                            reject(new errors_1.RequestError(error, this));
                        });
                        socket.once('secureConnect', () => {
                            if (!socket.authorized) {
                                socket.destroy();
                                return reject(new errors_1.RequestError(socket.authorizationError, this));
                            }
                            switch (socket.alpnProtocol) {
                                case false:
                                case constants_1.ALPNProtocols.HTTP1:
                                case constants_1.ALPNProtocols.HTTP1_1:
                                    {
                                        resolve({
                                            request: communications_1.Communications.HTTPS.request({
                                                createConnection: () => socket,
                                                ...this.options,
                                            }),
                                            info: {
                                                alpn: socket.alpnProtocol || constants_1.ALPNProtocols.NONE,
                                            },
                                        });
                                    }
                                    ;
                                    break;
                                case constants_1.ALPNProtocols.HTTP2:
                                    {
                                        const connection = communications_1.Communications.HTTP2.connect({
                                            host: this.options.hostname,
                                            port: parseInt(this.options.port),
                                        }, {
                                            createConnection: () => socket,
                                        });
                                        const options = Object.assign({}, this.options.headers, {
                                            ':method': this.options.method,
                                            ':authority': this.options.hostname,
                                            ':path': this.options.path,
                                        });
                                        resolve({
                                            request: connection.request(options),
                                            info: {
                                                alpn: socket.alpnProtocol,
                                                connection,
                                            },
                                        });
                                    }
                                    ;
                                    break;
                                default:
                                    {
                                        socket.destroy();
                                        reject(new errors_1.RequestError(`Invalid ALPN Protocol returned: ${socket.alpnProtocol}`, this));
                                    }
                                    ;
                            }
                        });
                    }
                    ;
                    break;
                default:
                    {
                        reject(new errors_1.RequestError(`Invalid Request Protocol: ${this.options.protocol}`, this));
                    }
                    ;
            }
        });
    }
    async send() {
        const { request, info } = await this._createRequest();
        return new Promise((resolve, reject) => {
            switch (info.alpn) {
                case constants_1.ALPNProtocols.NONE:
                case constants_1.ALPNProtocols.HTTP1:
                case constants_1.ALPNProtocols.HTTP1_1:
                    {
                        let error;
                        request.once('abort', () => {
                            let requestError;
                            if (error) {
                                requestError = new errors_1.RequestError(error, this);
                            }
                            else {
                                requestError = new errors_1.RequestError('Request aborted by the client.', this);
                            }
                            reject(requestError);
                        }).on('error', (e) => {
                            if (request.aborted) {
                                // we already handled the error from abort
                                return;
                            }
                            reject(new errors_1.RequestError(e, this));
                        });
                        const now = Date.now();
                        request.once('response', (response) => {
                            resolve(new response_1.Response(this, response, info, Date.now() - now));
                        }).setTimeout(this.settings.timeout, () => {
                            error = new Error(`[Request lasted for more than ${this.settings.timeout}ms.`);
                            request.abort();
                        });
                    }
                    ;
                    break;
                case constants_1.ALPNProtocols.HTTP2:
                    {
                        let error;
                        request.on('error', (e) => {
                            error = e;
                        }).once('close', () => {
                            if (!error) {
                                return;
                            }
                            info.connection.close();
                            error = new errors_1.RequestError(error, this);
                            reject(error);
                        });
                        const now = Date.now();
                        request.once('response', (headers) => {
                            resolve(new response_1.Response(this, request, info, Date.now() - now, headers));
                        }).setTimeout(this.settings.timeout, () => {
                            error = new Error(`Request lasted for more than ${this.settings.timeout}ms.`);
                            request.close();
                        });
                    }
                    ;
                    break;
            }
            if (Array.isArray(this.body)) {
                for (let chunk of this.body) {
                    request.write(chunk);
                }
                request.end();
            }
            else {
                request.end(this.body);
            }
        });
    }
    toString() {
        return `${this.options.method}-${url_1.format(this.url)}`;
    }
}
exports.Request = Request;
